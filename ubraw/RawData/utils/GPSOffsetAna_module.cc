////////////////////////////////////////////////////////////////////////
// Class:       GPSOffsetAna
// Module Type: analyzer
// File:        GPSOffsetAna_module.cc
//
// Purpose: Dump time stamps from DAQHeader and DAQHeaderTimeUBooNE.h
//
// FCL parameters:
//
// DAQHeaderProducer           - DAQHeader module label.
// DAQHeaderTimeUBooNEProducer - DAQHeaderTimeUBooNE module label.
// NumDump                     - Number of events to dump (default 10)
// UpdateMetadata              - Flag to specify whether to update input file metadata.
//                               Boolean (default false).
// MakeTree                    - Make and save GPS offset time tree.  Boolean (default false).
// 
// Created 24-Aug-2023  H. Greenlee
//
////////////////////////////////////////////////////////////////////////

#include <cstdint> // uint32_t
#include <iomanip>
#include <sstream>
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/FileBlock.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h" 
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "lardataobj/RawData/DAQHeader.h"
#include "ubobj/RawData/DAQHeaderTimeUBooNE.h"
#include "IFDH_service.h"
#include "TTree.h"

class GPSOffsetAna;

class GPSOffsetAna : public art::EDAnalyzer {
public:
  explicit GPSOffsetAna(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  GPSOffsetAna(GPSOffsetAna const &) = delete;
  GPSOffsetAna(GPSOffsetAna &&) = delete;
  GPSOffsetAna & operator = (GPSOffsetAna const &) = delete;
  GPSOffsetAna & operator = (GPSOffsetAna &&) = delete;

  // Overrides.
  void analyze(art::Event const & e) override;
  void respondToOpenInputFile(art::FileBlock const& fb) override;	
  void endJob() override;


private:

  // Fcl parameters.

  std::string fDAQHeaderProducer;             // DAQHeader module label.
  std::string fDAQHeaderTimeUBooNEProducer;   // DAQHeaderTimeUBooNE module label.
  int fNumDump;                               // Number of events to dump.
  bool fUpdateMetadata;                       // Metadata update flag.
  bool fMakeTree;                             // Tree flag.

  // Statistics.

  std::vector<std::string> fInputFiles;   // Input files seen.
  int fNumEvents;      // Number of events processed.
  double fTotalDiff;   // Total GPS-host time difference.
  double fTotalDiff2;  // Total GPS-host time square difference.

  // Tree variables.

  TTree* fTree;      // GPS offset tree.
  int fRun;          // Run.
  int fSubRun;       // Subrun.
  int fEvent;        // Event.
  float fGPSOffset;  // GPS offset value.
};

// Constructor.

GPSOffsetAna::GPSOffsetAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p),
  fNumDump(0),
  fUpdateMetadata(false),
  fMakeTree(false),
  fNumEvents(0),
  fTotalDiff(0.),
  fTotalDiff2(0.),
  fTree(0)
{

  // Extract fcl parameters.

  fDAQHeaderProducer = p.get<std::string>("DAQHeaderProducer");
  fDAQHeaderTimeUBooNEProducer = p.get<std::string>("DAQHeaderTimeUBooNEProducer");
  fNumDump = p.get<int>("NumDump", 10);
  fUpdateMetadata = p.get<bool>("UpdateMetadata", false);
  fMakeTree = p.get<bool>("MakeTree", false);

  // Maybe make tree.

  if(fMakeTree) {
    art::ServiceHandle<art::TFileService> tfs;
    art::TFileDirectory dir = tfs->mkdir("GPSOffsetAna", "GPS Timing Offsets");
    fTree = dir.make<TTree>("gps_offset", "GPS Timing Offsets");
    fTree->Branch("run", &fRun, "run/I");
    fTree->Branch("subrun", &fSubRun, "subrun/I");
    fTree->Branch("event", &fEvent, "event/I");
    fTree->Branch("gps_offset", &fGPSOffset, "GPS Offset (sec)/F");
  }

  // Report.

  mf::LogInfo("GPSOffsetAna") 
    << "GPSOffsetAna configured with the following parameters:\n"
    << "  DAQHeader producer = " << fDAQHeaderProducer << "\n"
    << "  DAQHeaderTimeUBooNE producer = " << fDAQHeaderTimeUBooNEProducer << "\n"
    << "  Number of events to dump = " << fNumDump << "\n"
    << "  Metadata update flag = " << fUpdateMetadata;
}

void GPSOffsetAna::analyze(art::Event const & e)
{
  ++fNumEvents;
  fRun = e.run();
  fSubRun = e.subRun();
  fEvent = e.event();
  fGPSOffset = 0.;

  // Collect dump and statistical information.

  double default_ts_fltsec = 0.;
  double gps_ts_fltsec = 0.;
  double ntp_ts_fltsec = 0.;

  // Get information from DAQHeader.

  art::Handle<raw::DAQHeader> hh1;
  e.getByLabel(fDAQHeaderProducer, hh1);
  if(hh1.isValid()) {
    time_t default_ts = hh1->GetTimeStamp();
    uint32_t default_ts_sec = uint32_t(default_ts >> 32);
    uint32_t default_ts_nsec = uint32_t(default_ts & 0xffffffff);
    default_ts_fltsec = default_ts_sec + 1.e-9 * default_ts_nsec;
  }

  // Get inforrmation from DAQHeaderTimeUBooNE.

  art::Handle<raw::DAQHeaderTimeUBooNE> hh2;
  e.getByLabel(fDAQHeaderTimeUBooNEProducer, hh2);
  if(hh2.isValid()) {

    time_t gps_ts = hh2->gps_time();
    uint32_t gps_ts_sec = uint32_t(gps_ts >> 32);
    uint32_t gps_ts_nsec = uint32_t(gps_ts & 0xffffffff);
    gps_ts_fltsec = gps_ts_sec + 1.e-9 * gps_ts_nsec;

    time_t ntp_ts = hh2->ntp_time();
    uint32_t ntp_ts_sec = uint32_t(ntp_ts >> 32);
    uint32_t ntp_ts_nsec = uint32_t(ntp_ts & 0xffffffff);
    ntp_ts_fltsec = ntp_ts_sec + 1.e-9 * ntp_ts_nsec;

    fGPSOffset = gps_ts_fltsec - ntp_ts_fltsec;
  }

  // Update statistics.

  fTotalDiff += fGPSOffset;
  fTotalDiff2 += fGPSOffset * fGPSOffset;

  // Maybe do dump.

  if(fNumEvents <= fNumDump || fNumDump == 0) {

    mf::LogInfo("GPSOffsetAna")
      << "\nTime Stamp Information:\n"
      << "Default time: " << std::fixed << std::setprecision(6) << default_ts_fltsec << "\n"
      << "GPS time    : " << std::fixed << std::setprecision(6) << gps_ts_fltsec << "\n"
      << "Host time   : " << std::fixed << std::setprecision(6) << ntp_ts_fltsec << "\n"
      << "GPS-host time difference: " << std::fixed << std::setprecision(6) << fGPSOffset;
  }

  // Maybe fill tree.

  if(fMakeTree)
    fTree->Fill();
}

void GPSOffsetAna::respondToOpenInputFile(art::FileBlock const& fb)
{
  std::string input_file = fb.fileName();
  fInputFiles.push_back(input_file);
  mf::LogInfo("GPSOffsetAna") << "Input file: " << input_file;
}

void GPSOffsetAna::endJob()
{
  double avg_diff = 0.;
  double avg_diff2 = 0.;
  if(fNumEvents > 0) {
    avg_diff = fTotalDiff / fNumEvents;
    avg_diff2 = fTotalDiff2 / fNumEvents;
  }
  double rms_diff = std::sqrt(avg_diff2 - avg_diff * avg_diff);
  mf::LogInfo log("GPSOffsetAna");
  log << "\nTime Stamp Summary:\n"
      << fNumEvents << " events dumped.\n"
      << "Average GPS-host time difference: " << std::fixed << std::setprecision(6) 
      << avg_diff << "\n"
      << "RMS GPS-host time difference    : " << std::fixed << std::setprecision(6) << rms_diff;

  // Maybe update metadata.

  if(fUpdateMetadata) {
    art::ServiceHandle<ifdh_ns::IFDH> ifdh;
    log << "\n";

    // Loop over input files.

    for(std::string input_file : fInputFiles) {

      // Parse out filename portion of input file path.

      boost::filesystem::path input_path(input_file);
      std::string filename = input_path.filename().string();
      log << "\nUpdating sam metadata for file " << filename << "\n"
          << "Setting gps.offset parameter to " << avg_diff << "\n";
      std::ostringstream json_md;
      json_md << "{\"gps.offset\": " << std::fixed << std::setprecision(6) << avg_diff << "}";
      int rc = ifdh->modifyMetadata(filename,  json_md.str());
      log << "Ifdh return code = " << rc;
    }
  }
}


DEFINE_ART_MODULE(GPSOffsetAna)
